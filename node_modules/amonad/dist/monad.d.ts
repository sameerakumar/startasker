import { Thenable } from './thenable';
interface Gettable<T, E> {
    get(): T | E;
    getOrElse(value: T): T;
    getOrThrow(): T;
}
export declare function fulfilled<T>(isMonad: (value: any) => boolean): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) => void;
export declare function rejected<T>(isMonad: (value: any) => boolean): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) => void;
export declare class CJustSuccess<T, E> implements Thenable<T>, Gettable<T, E> {
    private v;
    constructor(v: T);
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Thenable<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Thenable<TResult2>) | undefined | null): Thenable<TResult1 | TResult2>;
    get(): T;
    getOrElse(value: T): T;
    getOrThrow(): T;
}
export declare class CNoneFailure<T, E> implements Thenable<T>, Gettable<T, E> {
    protected v: E;
    constructor(v: E);
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Thenable<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Thenable<TResult2>) | undefined | null): Thenable<TResult1 | TResult2>;
    getOrElse(value: T): T;
    get(): E;
    getOrThrow(): T;
}
export {};
