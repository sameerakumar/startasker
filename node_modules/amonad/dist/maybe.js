"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const monad_1 = require("./monad");
const bindErrorMsg = "Maybe.bind() is should be full filled by monad decorator.";
exports.isMaybe = (obj) => exports.isNone(obj) || exports.isJust(obj);
exports.isNone = (obj) => obj instanceof CNone;
exports.isJust = (obj) => obj instanceof CJust;
exports.Just = (value) => new CJust(value);
exports.None = () => new CNone();
exports.Maybe = (value) => value !== null && value !== undefined
    ?
        exports.Just(value)
    :
        exports.None();
class CJust extends monad_1.CJustSuccess {
    bind(onJust, onNone) {
        throw new Error(bindErrorMsg);
    }
    isNone() {
        return false;
    }
    isJust() {
        return true;
    }
}
tslib_1.__decorate([
    monad_1.fulfilled(exports.isMaybe),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Function, Function]),
    tslib_1.__metadata("design:returntype", Object)
], CJust.prototype, "bind", null);
class CNone extends monad_1.CNoneFailure {
    constructor() {
        super(undefined);
    }
    bind(onJust, onNone) {
        throw new Error(bindErrorMsg);
    }
    isNone() {
        return true;
    }
    isJust() {
        return false;
    }
}
tslib_1.__decorate([
    monad_1.rejected(exports.isMaybe),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Function, Function]),
    tslib_1.__metadata("design:returntype", Object)
], CNone.prototype, "bind", null);
//# sourceMappingURL=maybe.js.map