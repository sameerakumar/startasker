import { CJustSuccess, CNoneFailure } from "./monad";
import { Thenable } from './thenable';
export declare type Throwable = Error | string;
interface IResult<T, E extends Throwable> extends Thenable<T> {
    bind<TResult1 = T, EResult1 extends Throwable = E, TResult2 = never, EResult2 extends Throwable = never>(onSuccess?: (value: T) => TResult1 | IResult<TResult1, EResult1>, onFailure?: (reason: E) => EResult2 | IResult<TResult2, EResult2>): Result<TResult1 | TResult2, EResult1 | EResult2>;
    isFailure(): this is Failure<T, E>;
    isSuccess(): this is Success<T, E>;
}
export declare type Success<T, E extends Throwable> = CSuccess<T, E>;
export declare type Failure<T, E extends Throwable> = CFailure<T, E>;
export declare type Result<T, E extends Throwable> = Success<T, E> | Failure<T, E>;
export declare const Success: <T, E extends Throwable>(value: T) => Result<T, E>;
export declare const Failure: <T, E extends Throwable>(error: E) => Result<T, E>;
export declare const Result: <T, E extends Throwable>(action: () => T | CSuccess<T, E> | CFailure<T, E>) => Result<T, E>;
export declare const isResult: <T, E extends Throwable>(obj: any) => obj is Result<T, E>;
export declare const isFailure: <T, E extends Throwable>(obj: any) => obj is CFailure<T, E>;
export declare const isSuccess: <T, E extends Throwable>(obj: any) => obj is CSuccess<T, E>;
declare class CSuccess<T, E extends Throwable> extends CJustSuccess<T, E> implements IResult<T, E> {
    bind<TResult1 = T, EResult1 extends Throwable = E, TResult2 = never, EResult2 extends Throwable = never>(onSuccess?: (value: T) => TResult1 | Result<TResult1, EResult1>, onFailure?: (reason: E) => EResult2 | Result<TResult2, EResult2>): Result<TResult1 | TResult2, EResult1 | EResult2>;
    isFailure(): this is Failure<T, E>;
    isSuccess(): this is Success<T, E>;
}
declare class CFailure<T, E extends Throwable> extends CNoneFailure<T, E> implements IResult<T, E> {
    bind<TResult1 = T, EResult1 extends Throwable = E, TResult2 = never, EResult2 extends Throwable = never>(onSuccess?: (value: T) => TResult1 | Result<TResult1, EResult1>, onFailure?: (reason: E) => EResult2 | Result<TResult2, EResult2>): Result<TResult1 | TResult2, EResult1 | EResult2>;
    isFailure(): this is Failure<T, E>;
    isSuccess(): this is Success<T, E>;
}
export {};
