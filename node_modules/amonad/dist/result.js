"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const monad_1 = require("./monad");
const bindErrorMsg = "Result.bind() is should be full filled by monad decorator.";
exports.Success = (value) => new CSuccess(value);
exports.Failure = (error) => new CFailure(error);
exports.Result = (action) => {
    try {
        const result = action();
        if (exports.isResult(result)) {
            return result;
        }
        else {
            return exports.Success(result);
        }
    }
    catch (e) {
        return exports.Failure(e);
    }
};
exports.isResult = (obj) => exports.isSuccess(obj) || exports.isFailure(obj);
exports.isFailure = (obj) => obj instanceof CFailure;
exports.isSuccess = (obj) => obj instanceof CSuccess;
class CSuccess extends monad_1.CJustSuccess {
    bind(onSuccess, onFailure) {
        throw new Error(bindErrorMsg);
    }
    isFailure() {
        return false;
    }
    isSuccess() {
        return true;
    }
}
tslib_1.__decorate([
    monad_1.fulfilled(exports.isResult),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Function, Function]),
    tslib_1.__metadata("design:returntype", Object)
], CSuccess.prototype, "bind", null);
class CFailure extends monad_1.CNoneFailure {
    bind(onSuccess, onFailure) {
        throw new Error(bindErrorMsg);
    }
    isFailure() {
        return true;
    }
    isSuccess() {
        return false;
    }
}
tslib_1.__decorate([
    monad_1.rejected(exports.isResult),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Function, Function]),
    tslib_1.__metadata("design:returntype", Object)
], CFailure.prototype, "bind", null);
//# sourceMappingURL=result.js.map