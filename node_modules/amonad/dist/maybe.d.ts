import { CJustSuccess, CNoneFailure } from "./monad";
import { Thenable } from './thenable';
interface IMaybe<T> extends Thenable<T> {
    bind<TResult1 = T, TResult2 = never>(onJust?: ((value: T) => TResult1 | IMaybe<TResult1> | void), onNone?: (() => IMaybe<TResult2> | void)): Maybe<TResult1 | TResult2>;
    isNone(): this is None<T>;
    isJust(): this is Just<T>;
}
export declare type Just<T> = CJust<T>;
export declare type None<T> = CNone<T>;
export declare type Maybe<T> = Just<T> | None<T>;
export declare const isMaybe: <T>(obj: any) => obj is Maybe<T>;
export declare const isNone: <T>(obj: any) => obj is CNone<T>;
export declare const isJust: <T>(obj: any) => obj is CJust<T>;
export declare const Just: <T>(value: T) => Maybe<T>;
export declare const None: <T>() => Maybe<T>;
export declare const Maybe: <T>(value: T | null | undefined) => Maybe<T>;
declare class CJust<T> extends CJustSuccess<T, undefined> implements IMaybe<T> {
    bind<TResult1 = T, TResult2 = never>(onJust?: (value: T) => TResult1 | Maybe<TResult1>, onNone?: () => Maybe<TResult2>): Maybe<TResult1 | TResult2>;
    isNone(): this is None<T>;
    isJust(): this is Just<T>;
}
declare class CNone<T> extends CNoneFailure<T, undefined> implements IMaybe<T> {
    constructor();
    bind<TResult1 = T, TResult2 = never>(onJust?: (value: T) => TResult1 | Maybe<TResult1>, onNone?: () => Maybe<TResult2>): Maybe<TResult1 | TResult2>;
    isNone(): this is None<T>;
    isJust(): this is Just<T>;
}
export {};
